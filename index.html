<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoshop Pen Tool Curve Practice</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            background-image: linear-gradient(#add8e6 1px, transparent 1px),
                              linear-gradient(90deg, #add8e6 1px, transparent 1px);
            background-size: 20px 20px;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Special Elite', cursive;
            color: #ff69b4;
        }
        #canvas {
            border: 1px solid #000;
            margin: 20px 0;
            background-color: white;
            width: 700px;
            height: 400px;
        }
        #controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px;
            cursor: pointer;
            background-color: #ff69b4;
            color: white;
            border: none;
            border-radius: 5px;
            font-family: 'Special Elite', cursive;
        }
        #instructions, #photoshop-tip {
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
        }
        #shapeSelector {
            margin-bottom: 20px;
        }
        #photoshop-tip {
            margin-top: 30px;
            text-align: left;
            border: 1px solid #ddd;
        }
        #photoshop-tip h2 {
            margin-top: 0;
        }
        #photoshop-tip ol {
            padding-left: 20px;
        }
        #photoshop-tip li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Pen Tool Curve Practice</h1>
    <div id="instructions">
        Click to place anchor points. Click and drag to create curve handles. 
        Try to recreate the blue curve shape as closely as possible!<br>
        Hold Option (Alt) key while creating or adjusting handles for asymmetrical curves.
    </div>
    <div id="shapeSelector">
        <label for="shapes">Choose a shape:</label>
        <select id="shapes" onchange="changeShape()">
            <option value="infinity">Infinity</option>
            <option value="heart">Heart</option>
            <option value="wave">Wave</option>
        </select>
    </div>
    <div id="controls">
        <button onclick="undoLastPoint()">Undo Last Point</button>
        <button onclick="resetCanvas()">Reset Canvas</button>
        <button onclick="checkAccuracy()">Check Accuracy</button>
    </div>
    <canvas id="canvas" width="700" height="400"></canvas>
    <div id="feedback"></div>

    <div id="photoshop-tip">
        <h2>Important Photoshop Tip:</h2>
        <p>When using the Pen Tool to cut out shapes in Photoshop, remember these steps:</p>
        <ol>
            <li>Create your path with the Pen Tool</li>
            <li>Right-click on the path</li>
            <li>Select "Make Selection"</li>
            <li>Press Delete to remove the area outside your selection</li>
        </ol>
        <p>Note: This is typically the quickest way to cut out shapes using the Pen Tool in Photoshop.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let path = [];
        let isDrawing = false;
        let currentHandle = null;
        let isAltKeyPressed = false;
        let currentShape = "infinity";
        let activePoint = null;

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        function handleKeyDown(e) {
            if (e.key === 'Alt' || e.key === 'Option') {
                isAltKeyPressed = true;
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'Alt' || e.key === 'Option') {
                isAltKeyPressed = false;
            }
        }

        function startDrawing(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if we're close to the first point to close the path
            if (path.length > 2) {
                const firstPoint = path[0];
                const distance = Math.sqrt(Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2));
                if (distance < 20) {
                    path.push({...firstPoint, isClosed: true});
                    drawPath();
                    isDrawing = false;
                    return;
                }
            }
            
            // Check if we're clicking on an existing point
            for (let i = 0; i < path.length; i++) {
                const point = path[i];
                if (Math.abs(x - point.x) < 10 && Math.abs(y - point.y) < 10) {
                    activePoint = point;
                    isDrawing = true;
                    currentHandle = 'handleOut';
                    return;
                }
            }
            
            // If not, create a new point
            activePoint = {x, y, handleIn: null, handleOut: null};
            path.push(activePoint);
            isDrawing = true;
            currentHandle = 'handleOut';
            
            drawPath();
        }

        function draw(e) {
            if (!isDrawing || !activePoint) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentHandle) {
                activePoint[currentHandle] = {x, y};
                if (!isAltKeyPressed) {
                    const oppositeHandle = currentHandle === 'handleOut' ? 'handleIn' : 'handleOut';
                    activePoint[oppositeHandle] = {
                        x: activePoint.x - (activePoint[currentHandle].x - activePoint.x),
                        y: activePoint.y - (activePoint[currentHandle].y - activePoint.y)
                    };
                }
            }
            
            drawPath();
        }

        function stopDrawing() {
            isDrawing = false;
            activePoint = null;
        }

        function drawPath() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGoalShape();
            
            if (path.length > 0) {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                
                for (let i = 1; i < path.length; i++) {
                    const prev = path[i-1];
                    const curr = path[i];
                    
                    const prevOut = prev.handleOut || {x: prev.x, y: prev.y};
                    const currIn = curr.handleIn || {x: curr.x, y: curr.y};
                    
                    ctx.bezierCurveTo(
                        prevOut.x, prevOut.y,
                        currIn.x, currIn.y,
                        curr.x, curr.y
                    );
                }
                
                if (path[path.length - 1].isClosed) {
                    ctx.closePath();
                }
                
                ctx.stroke();

                // Draw handles and points
                ctx.fillStyle = 'red';
                path.forEach((point, index) => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (point.handleOut) {
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(point.handleOut.x, point.handleOut.y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(point.handleOut.x, point.handleOut.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (point.handleIn) {
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(point.handleIn.x, point.handleIn.y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(point.handleIn.x, point.handleIn.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        }

        function undoLastPoint() {
            path.pop();
            drawPath();
        }

        function resetCanvas() {
            path = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGoalShape();
        }

        function drawGoalShape() {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.beginPath();
            
            switch(currentShape) {
                case "infinity":
                    ctx.moveTo(150, 200);
                    ctx.bezierCurveTo(250, 100, 450, 100, 550, 200);
                    ctx.bezierCurveTo(450, 300, 250, 300, 150, 200);
                    break;
                case "heart":
                    ctx.moveTo(350, 150);
                    ctx.bezierCurveTo(300, 100, 250, 150, 250, 200);
                    ctx.bezierCurveTo(250, 250, 350, 300, 350, 300);
                    ctx.bezierCurveTo(350, 300, 450, 250, 450, 200);
                    ctx.bezierCurveTo(450, 150, 400, 100, 350, 150);
                    break;
                case "wave":
                    ctx.moveTo(100, 200);
                    ctx.bezierCurveTo(200, 100, 300, 300, 400, 200);
                    ctx.bezierCurveTo(500, 100, 600, 300, 700, 200);
                    break;
            }
            
            ctx.stroke();
            ctx.restore();
        }

        function changeShape() {
            currentShape = document.getElementById('shapes').value;
            resetCanvas();
        }

        function checkAccuracy() {
            let totalDistance = 0;
            const totalPoints = 100;

            for (let i = 0; i < totalPoints; i++) {
                const t = i / (totalPoints - 1);
                const goalPoint = getPointOnGoalCurve(t);
                const userPoint = getPointOnUserCurve(t);
                const distance = Math.sqrt(Math.pow(goalPoint.x - userPoint.x, 2) + Math.pow(goalPoint.y - userPoint.y, 2));
                totalDistance += distance;
            }

            const averageDistance = totalDistance / totalPoints;
            const maxAllowedDistance = 50;
            let score = 10 - (averageDistance / maxAllowedDistance) * 9;
            score = Math.max(1, Math.min(10, Math.round(score)));

            const feedback = [
                "Great start! You're beginning to grasp the pen tool. Keep practicing!",
                "Nice attempt! Try to follow the blue line more closely.",
                "Good effort! Your curves are taking shape. Keep refining!",
                "Well done! You're getting the hang of it. Focus on smoother curves.",
                "Impressive progress! Your shape is becoming more accurate.",
                "Excellent work! Your curves are very close to the target.",
                "Outstanding control! You're nearly matching the shape perfectly.",
                "Amazing precision! You're mastering the pen tool.",
                "Exceptional skill! Your curves are almost indistinguishable from the goal.",
                "Perfect! Your mastery of the pen tool is evident. Fantastic job!"
            ];

            let detailedFeedback = `Score: ${score}/10 - ${feedback[score - 1]}\n\n`;
            detailedFeedback += `Average Distance: ${Math.round(averageDistance)}px\n`;
            detailedFeedback += "Tip: " + getTip(score);

            document.getElementById('feedback').innerHTML = detailedFeedback.replace(/\n/g, '<br>');
        }

        function getTip(score) {
            if (score <= 3) return "Try using fewer anchor points and focus on the overall shape.";
            if (score <= 6) return "Adjust your curve handles to smooth out the lines.";
            if (score <= 9) return "Fine-tune your anchor point positions for perfect symmetry.";
            return "Challenge yourself with more complex shapes!";
        }

        function getPointOnGoalCurve(t) {
            switch(currentShape) {
                case "infinity":
                    return getInfinityPoint(t);
                case "heart":
                    return getHeartPoint(t);
                case "wave":
                    return getWavePoint(t);
                default:
                    return {x: 0, y: 0};
            }
        }

        function getInfinityPoint(t) {
            const x = 150 * Math.pow(1-t, 3) + 550 * Math.pow(t, 3) + 3 * (250 * Math.pow(1-t, 2) * t + 450 * (1-t) * Math.pow(t, 2));
            const y = 200 * Math.pow(1-t, 3) + 200 * Math.pow(t, 3) + 3 * (100 * Math.pow(1-t, 2) * t + 300 * (1-t) * Math.pow(t, 2));
            return {x, y};
        }

        function getHeartPoint(t) {
            if (t < 0.5) {
                const tt = t * 2;
                const x = 350 - 100 * Math.sin(tt * Math.PI);
                const y = 200 - 50 * Math.cos(tt * Math.PI);
                return {x, y};
            } else {
                const tt = (t - 0.5) * 2;
                const x = 350 + 100 * Math.sin(tt * Math.PI);
                const y = 200 - 50 * Math.cos(tt * Math.PI);
                return {x, y};
            }
        }

        function getWavePoint(t) {
            const x = 100 + 600 * t;
            const y = 200 + 100 * Math.sin(t * Math.PI * 2);
            return {x, y};
        }

        function getPointOnUserCurve(t) {
            if (path.length < 2) return {x: 0, y: 0};
            let segmentT = t * (path.length - 1);
            let segmentIndex = Math.floor(segmentT);
            let localT = segmentT - segmentIndex;
            
            if (segmentIndex >= path.length - 1) {
                segmentIndex = path.length - 2;
                localT = 1;
            }

            const p0 = path[segmentIndex];
            const p1 = path[segmentIndex + 1];

            if (!p0.handleOut || !p1.handleIn) {
                return {
                    x: p0.x * (1 - localT) + p1.x * localT,
                    y: p0.y * (1 - localT) + p1.y * localT
                };
            }

            const cp1 = p0.handleOut;
            const cp2 = p1.handleIn;

            const x = Math.pow(1-localT, 3) * p0.x +
                      3 * Math.pow(1-localT, 2) * localT * cp1.x +
                      3 * (1-localT) * Math.pow(localT, 2) * cp2.x +
                      Math.pow(localT, 3) * p1.x;

            const y = Math.pow(1-localT, 3) * p0.y +
                      3 * Math.pow(1-localT, 2) * localT * cp1.y +
                      3 * (1-localT) * Math.pow(localT, 2) * cp2.y +
                      Math.pow(localT, 3) * p1.y;

            return {x, y};
        }

        drawGoalShape();
    </script>
</body>
</html>
