<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photoshop Pen Tool Curve Practice</title>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            background-image: linear-gradient(#add8e6 1px, transparent 1px),
                              linear-gradient(90deg, #add8e6 1px, transparent 1px);
            background-size: 20px 20px;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Special Elite', cursive;
            color: #ff69b4;
        }
        #canvas {
            border: 1px solid #000;
            margin: 20px 0;
            background-color: white;
        }
        #controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px;
            cursor: pointer;
            background-color: #ff69b4;
            color: white;
            border: none;
            border-radius: 5px;
            font-family: 'Special Elite', cursive;
        }
        #instructions, #photoshop-tip {
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
        }
        #shapeSelector {
            margin-bottom: 20px;
        }
        #photoshop-tip {
            margin-top: 30px;
            text-align: left;
            border: 1px solid #ddd;
        }
        #photoshop-tip h2 {
            margin-top: 0;
        }
        #photoshop-tip ol {
            padding-left: 20px;
        }
        #photoshop-tip li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Pen Tool Curve Practice</h1>
    <div id="instructions">
        Click to place anchor points. Click and drag to create curve handles. 
        Try to recreate the blue curve shape as closely as possible!<br>
        Hold Option (Alt) key while creating or adjusting handles for asymmetrical curves.
    </div>
    <div id="shapeSelector">
        <label for="shapes">Choose a shape:</label>
        <select id="shapes" onchange="changeShape()">
            <option value="infinity">Infinity</option>
            <option value="heart">Heart</option>
            <option value="wave">Wave</option>
        </select>
    </div>
    <div id="controls">
        <button onclick="undoLastPoint()">Undo Last Point</button>
        <button onclick="resetCanvas()">Reset Canvas</button>
        <button onclick="checkAccuracy()">Check Accuracy</button>
    </div>
    <canvas id="canvas" width="500" height="300"></canvas>
    <div id="feedback"></div>

    <div id="photoshop-tip">
        <h2>Important Photoshop Tip:</h2>
        <p>When using the Pen Tool to cut out shapes in Photoshop, remember these steps:</p>
        <ol>
            <li>Create your path with the Pen Tool</li>
            <li>Right-click on the path</li>
            <li>Select "Make Selection"</li>
            <li>Press Delete to remove the area outside your selection</li>
        </ol>
        <p>Note: This is typically the quickest way to cut out shapes using the Pen Tool in Photoshop.</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let path = [];
        let isDrawing = false;
        let currentHandle = null;
        let isAltKeyPressed = false;
        let currentShape = "infinity";

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        function handleKeyDown(e) {
            if (e.key === 'Alt' || e.key === 'Option') {
                isAltKeyPressed = true;
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'Alt' || e.key === 'Option') {
                isAltKeyPressed = false;
            }
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const distanceThreshold = 10; // pixels
            
            if (path.length === 0) {
                // First point
                path.push({x, y, handleIn: null, handleOut: {x, y}});
            } else {
                const lastPoint = path[path.length - 1];
                const distance = Math.sqrt(Math.pow(x - lastPoint.x, 2) + Math.pow(y - lastPoint.y, 2));
                
                if (distance < distanceThreshold) {
                    // Adjusting handle of existing point
                    currentHandle = 'handleOut';
                } else {
                    // New point
                    path.push({x, y, handleIn: null, handleOut: {x, y}});
                }
            }
            drawPath();
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (path.length > 0) {
                const lastPoint = path[path.length - 1];
                if (currentHandle) {
                    lastPoint[currentHandle] = {x, y};
                    if (currentHandle === 'handleOut' && !isAltKeyPressed) {
                        lastPoint.handleIn = {
                            x: lastPoint.x - (lastPoint.handleOut.x - lastPoint.x),
                            y: lastPoint.y - (lastPoint.handleOut.y - lastPoint.y)
                        };
                    }
                } else {
                    // Always update handleOut when dragging
                    lastPoint.handleOut = {x, y};
                    if (!isAltKeyPressed) {
                        lastPoint.handleIn = {
                            x: lastPoint.x - (x - lastPoint.x),
                            y: lastPoint.y - (y - lastPoint.y)
                        };
                    }
                }
                drawPath();
            }
        }

        function stopDrawing() {
            isDrawing = false;
            currentHandle = null;
        }

        function drawPath() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGoalShape();
            ctx.beginPath();
            for (let i = 0; i < path.length; i++) {
                if (i === 0) {
                    ctx.moveTo(path[i].x, path[i].y);
                } else {
                    const prev = path[i-1];
                    const curr = path[i];
                    if (prev.handleOut && curr.handleIn) {
                        ctx.bezierCurveTo(
                            prev.handleOut.x, prev.handleOut.y,
                            curr.handleIn.x, curr.handleIn.y,
                            curr.x, curr.y
                        );
                    } else {
                        ctx.lineTo(curr.x, curr.y);
                    }
                }
            }
            ctx.stroke();

            // Draw handles
            ctx.fillStyle = 'red';
            path.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
                if (point.handleOut) {
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(point.handleOut.x, point.handleOut.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(point.handleOut.x, point.handleOut.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (point.handleIn) {
                    ctx.beginPath();
                    ctx.moveTo(point.x, point.y);
                    ctx.lineTo(point.handleIn.x, point.handleIn.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(point.handleIn.x, point.handleIn.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function undoLastPoint() {
            path.pop();
            drawPath();
        }

        function resetCanvas() {
            path = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGoalShape();
        }

        function drawGoalShape() {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.beginPath();
            
            switch(currentShape) {
                case "infinity":
                    ctx.moveTo(50, 150);
                    ctx.bezierCurveTo(150, 50, 350, 50, 450, 150);
                    ctx.bezierCurveTo(350, 250, 150, 250, 50, 150);
                    break;
                case "heart":
                    ctx.moveTo(250, 60);
                    ctx.bezierCurveTo(200, 20, 150, 60, 150, 110);
                    ctx.bezierCurveTo(150, 160, 250, 220, 250, 220);
                    ctx.bezierCurveTo(250, 220, 350, 160, 350, 110);
                    ctx.bezierCurveTo(350, 60, 300, 20, 250, 60);
                    break;
                case "wave":
                    ctx.moveTo(50, 150);
                    ctx.bezierCurveTo(100, 50, 150, 250, 200, 150);
                    ctx.bezierCurveTo(250, 50, 300, 250, 350, 150);
                    ctx.bezierCurveTo(400, 50, 450, 250, 500, 150);
                    break;
            }
            
            ctx.stroke();
            ctx.restore();
        }

        function changeShape() {
            currentShape = document.getElementById('shapes').value;
            resetCanvas();
        }

        function checkAccuracy() {
            let score = 0;
            const totalPoints = 100;
            let closestDistance = Infinity;
            let furthestDistance = 0;
            let averageDistance = 0;

            for (let i = 0; i < totalPoints; i++) {
                const t = i / (totalPoints - 1);
                const goalPoint = getPointOnGoalCurve(t);
                const userPoint = getPointOnUserCurve(t);
                const distance = Math.sqrt(Math.pow(goalPoint.x - userPoint.x, 2) + Math.pow(goalPoint.y - userPoint.y, 2));
                
                closestDistance = Math.min(closestDistance, distance);
                furthestDistance = Math.max(furthestDistance, distance);
                averageDistance += distance;
                if (distance < 50) {
                    score += 1 - (distance / 50);
                }
            }
            averageDistance /= totalPoints;

            // Base score for attempt
            let baseScore = 3;
            
            // Additional points for overall shape resemblance
            const shapeScore = Math.max(0, 5 - (averageDistance / 20));
            
            // Points for consistency
            const consistencyScore = Math.max(0, 2 - ((furthestDistance - closestDistance) / 50));
            
            // Calculate final score
            const finalScore = Math.min(10, Math.max(1, Math.round(baseScore + shapeScore + consistencyScore)));

            const feedback = [
                "Great start! You're beginning to grasp the pen tool. Keep practicing!",
                "Nice attempt! Try to follow the blue line more closely.",
                "Good effort! Your curves are taking shape. Keep refining!",
                "Well done! You're getting the hang of it. Focus on smoother curves.",
                "Impressive progress! Your shape is becoming more accurate.",
                "Excellent work! Your curves are very close to the target.",
                "Outstanding control! You're nearly matching the shape perfectly.",
                "Amazing precision! You're mastering the pen tool.",
                "Exceptional skill! Your curves are almost indistinguishable from the goal.",
                "Perfect! Your mastery of the pen tool is evident. Fantastic job!"
            ];

            let detailedFeedback = `Score: ${finalScore}/10 - ${feedback[finalScore - 1]}\n\n`;
            detailedFeedback += `Shape Accuracy: ${Math.round(shapeScore * 20)}%\n`;
            detailedFeedback += `Curve Consistency: ${Math.round(consistencyScore * 50)}%\n\n`;
            detailedFeedback += "Tip: " + getTip(finalScore);

            document.getElementById('feedback').innerHTML = detailedFeedback.replace(/\n/g, '<br>');
        }

        function getTip(score) {
            if (score <= 3) return "Try using fewer anchor points and focus on the overall shape.";
            if (score <= 6) return "Adjust your curve handles to smooth out the lines.";
            if (score <= 9) return "Fine-tune your anchor point positions for perfect symmetry.";
            return "Challenge yourself with more complex shapes!";
        }

        function getPointOnGoalCurve(t) {
            switch(currentShape) {
                case "infinity":
                    return getInfinityPoint(t);
                case "heart":
                    return getHeartPoint(t);
                case "wave":
                    return getWavePoint(t);
                default:
                    return {x: 0, y: 0};
            }
        }

        function getInfinityPoint(t) {
            const x = 50 * Math.pow(1-t, 3) + 450 * Math.pow(t, 3) + 3 * (150 * Math.pow(1-t, 2) * t + 350 * (1-t) * Math.pow(t, 2));
            const y = 150 * Math.pow(1-t, 3) + 150 * Math.pow(t, 3) + 3 * (50 * Math.pow(1-t, 2) * t + 250 * (1-t) * Math.pow(t, 2));
            return {x, y};
        }

        function getHeartPoint(t) {
            // Simplified heart shape calculation
            if (t < 0.5) {
                const tt = t * 2;
                const x = 250 - 100 * Math.sin(tt * Math.PI);
                const y = 110 - 50 * Math.cos(tt * Math.PI);
                return {x, y};
            } else {
                const tt = (t - 0.5) * 2;
                const x = 250 + 100 * Math.sin(tt * Math.PI);
                const y = 110 - 50 * Math.cos(tt * Math.PI);
                return {x, y};
            }
        }

        function getWavePoint(t) {
            const x = 50 + 450 * t;
            const y = 150 + 100 * Math.sin(t * Math.PI * 3);
            return {x, y};
        }

        function getPointOnUserCurve(t) {
            if (path.length < 2) return {x: 0, y: 0};
            let segmentT = t * (path.length - 1);
            let segmentIndex = Math.floor(segmentT);
            let localT = segmentT - segmentIndex;
            
            if (segmentIndex >= path.length - 1) {
                segmentIndex = path.length - 2;
                localT = 1;
            }

            const p0 = path[segmentIndex];
            const p1 = path[segmentIndex + 1];

            if (!p0.handleOut || !p1.handleIn) {
                return {
                    x: p0.x * (1 - localT) + p1.x * localT,
                    y: p0.y * (1 - localT) + p1.y * localT
                };
            }

            const cp1 = p0.handleOut;
            const cp2 = p1.handleIn;

            const x = Math.pow(1-localT, 3) * p0.x +
                      3 * Math.pow(1-localT, 2) * localT * cp1.x +
                      3 * (1-localT) * Math.pow(localT, 2) * cp2.x +
                      Math.pow(localT, 3) * p1.x;

            const y = Math.pow(1-localT, 3) * p0.y +
                      3 * Math.pow(1-localT, 2) * localT * cp1.y +
                      3 * (1-localT) * Math.pow(localT, 2) * cp2.y +
                      Math.pow(localT, 3) * p1.y;

            return {x, y};
        }

        drawGoalShape();
    </script>
</body>
</html>
